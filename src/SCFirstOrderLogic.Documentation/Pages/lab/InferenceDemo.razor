@page "/lab"

@using SCFirstOrderLogic;
@using SCFirstOrderLogic.ExampleDomains.FromAIaMA.Chapter9.UsingSentenceParser;
@using SCFirstOrderLogic.Inference;
@using SCFirstOrderLogic.Inference.BackwardChaining;
@using SCFirstOrderLogic.Inference.ForwardChaining;
@using SCFirstOrderLogic.Inference.Resolution;
@using SCFirstOrderLogic.SentenceCreation;
@using System.ComponentModel.DataAnnotations;
@using static SCFirstOrderLogic.SentenceCreation.SentenceFactory;
@inject IJSRuntime JS

<h3>Lab - Inference Demo</h3>

<div class="alert alert-primary" role="alert">
    <p>
        This page is an interactive demonstration of inference with SCFirstOrderLogic that runs in your browser. Note that:
    </p>
    <ul>
        <li>
            The knowledge base implementations in this package are very basic for now, to the extent that it is very easy to create queries that they will struggle with.
            Resolution in particular will generally fail to terminate if the query is not provable (a linear strategy and some knowledge of subsumption is on the TODO list..).
            The goal of this package (for now, at least) is learning and experimentation more than anything else - so I maintain that there is value here as it stands - but improvements will be made (though not to any particular timeline).
        </li>
        <li>
            Querying with this page is slower than it generally would be, due to limitations of the app framework used.
            Blazor WASM's single-threaded nature necessitates the use of clause stores with some delays coded in, so as not to lock up the browser if a query takes a long time.
        </li>
        <li>Use the buttons at the top of the form to populate it with example queries, taken from "Artificial Intelligence: A Modern Approach".</li>
        <li>Guidance for writing sentences as strings can be found on the <a href="getting-started#writing-sentences-as-strings">getting started</a> page.</li>
        <li>
            The source code for this page can be found <a href="https://github.com/sdcondon/SCFirstOrderLogic/blob/main/src/SCFirstOrderLogic.Documentation/Pages/lab/InferenceDemo.razor">here</a>.
        </li>
    </ul>
    <!--<button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close" onclick="$('.alert').css('display', 'none')"></button>-->
</div>

<EditForm Model=@formData OnSubmit=@HandleFormSubmission style="font-family: monospace">
    <DataAnnotationsValidator />
    <div class="form-group">
        <label>Presets</label>
        <div>
            @foreach (var kvp in Presets)
            {
                <button @onclick="@(() => formData = kvp.Value.Invoke())">@kvp.Key</button>
                @(" ")
            }
        </div>
    </div>
    <div class="form-group">
        <label for="kbTypeSelect">Knowledge Base Type</label>
        <InputSelect class="form-control" id="kbTypeSelect" @bind-Value=formData.KnowledgeBaseDescription>
            @foreach (var key in KnowledgeBaseOptions.Keys)
            {
                <option>@key</option>
            }
        </InputSelect>
    </div>
    <div class="form-group">
        <label for="factsTextArea">Knowledge</label>
        <InputTextArea class="form-control" id="factsTextArea" @bind-Value=formData.Knowledge rows="8" />
        <ValidationMessage For="@(() => formData.Knowledge)" />
    </div>
    <div class="form-group">
        <label for="queryText">Query</label>
        <InputText class="form-control" id="queryText" @bind-Value=formData.Query />
        <ValidationMessage For="() => formData.Query" />
    </div>
    <div class="form-group mt-2">
        <button type="submit" class="btn btn-primary" disabled="@(currentQueryExecution != null && !currentQueryExecution.IsCompleted)">Submit</button>
    </div>
</EditForm>

@if (currentQueryExecution != null)
{
    if (currentQueryExecution.IsCompletedSuccessfully)
    {
        <div class="alert alert-success mt-4" role="alert">
            <h3>Query Complete</h3>
            <p><pre>Query result: @currentQuery!.Result</pre></p>

            @if (currentQuery!.Result)
            {
                var details = currentQuery! switch
                {
                    BackwardChainingQuery bcq => bcq.ResultExplanation,
                    ForwardChainingQuery fcq => fcq.ResultExplanation,
                    ResolutionQuery rq => rq.ResultExplanation,
                    _ => "?"
                };

                <p><pre>@details</pre></p>
            }
        </div>
    }
    else if (currentQueryExecution.IsCanceled)
    {
        <div class="alert alert-warning mt-4" role="alert">
            <h3>Query Cancelled</h3>
        </div>
    }
    else if (currentQueryExecution.IsFaulted)
    {
        <div class="alert alert-danger mt-4" role="alert">
            <h3>Query Failed</h3>
            <p>
                Sorry, this demo isn't perfect.
                In particular, the input validation is a little lacklustre.
                It'll hopefully improve gradually over time.
                In case it helps, here's the details of the exception that was thrown:
            </p>
            @foreach (var e in currentQueryExecution.Exception!.InnerExceptions)
            {
                <p><pre>@(e.ToString())</pre></p>
            }
        </div>
    }
    else
    {
        <div class="alert alert-primary mt-4" role="alert">
            <h3>Query In Progress</h3>
            <p>
                If you see this for more than a few seconds, the chances are you've fashioned a query that the current KB implementation can't deal with.
                Click the "Cancel Query" button to abort.
            </p>
            <p>
                <button type="button" class="btn btn-secondary" @onclick=@(() => currentQueryCancellation?.Cancel())>Cancel Query</button>
            </p>
        </div>
    }
}

@code {
    private static Dictionary<string, Func<IKnowledgeBase>> KnowledgeBaseOptions = new()
    {
        ["Backward Chaining"] = () => new BackwardChainingKnowledgeBase(
            new BlazorWasmBCClauseStore()),

        ["Forward Chaining"] = () => new ForwardChainingKnowledgeBase(
            new BlazorWasmFCClauseStore()),

        ["Resolution (Unit Preference)"] = () => new ResolutionKnowledgeBase(new DelegateResolutionStrategy(
            new BlazorWasmResClauseStore(),
            DelegateResolutionStrategy.Filters.None,
            DelegateResolutionStrategy.PriorityComparisons.UnitPreference)),
    };

    private static Dictionary<string, Func<FormData>> Presets = new()
    {
        ["[Empty]"] = () => new(
            knowledgeBaseDescription: "Backward Chaining",
            knowledge: string.Empty,
            query: string.Empty),

        ["Crime"] = () => new(
            knowledgeBaseDescription: "Backward Chaining",
            knowledge: string.Join(Environment.NewLine, CrimeDomain.UnparsedAxioms),
            query: CrimeDomain.UnparsedExampleQuery),

        ["Curiousity and the Cat"] = () => new(
            knowledgeBaseDescription: "Resolution (Unit Preference)",
            knowledge: string.Join(Environment.NewLine, CuriousityAndTheCatDomain.UnparsedAxioms),
            query: CuriousityAndTheCatDomain.UnparsedExampleQuery),
    };

    private FormData formData = Presets["Crime"].Invoke();

    private CancellationTokenSource? currentQueryCancellation;
    private IQuery? currentQuery;
    private Task? currentQueryExecution;

    private async Task HandleFormSubmission(EditContext editContext)
    {
        try
        {
            // Instantiate and start the new query, then re-render (to e.g. disable the submit button).
            currentQueryCancellation = new CancellationTokenSource();
            currentQuery = await MakeQueryAsync(formData, currentQueryCancellation.Token);
            currentQueryExecution = currentQuery.ExecuteAsync(currentQueryCancellation.Token);
            await InvokeAsync(StateHasChanged);

            // Await query completion, then re-render (to e.g. re-enable the submit button).    
            await currentQueryExecution;
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception e)
        {
            // yes, this is a little ugly..
            if (e is not TaskCanceledException)
            {
                currentQueryExecution = Task.FromException(e);
            }
        }
    }

    private async Task<IQuery> MakeQueryAsync(FormData formData, CancellationToken cancellationToken)
    {
        IKnowledgeBase knowledgeBase = KnowledgeBaseOptions[formData.KnowledgeBaseDescription].Invoke();
        await knowledgeBase.TellAsync(SentenceParser.ParseList(formData.Knowledge), cancellationToken);

        return await knowledgeBase.CreateQueryAsync(SentenceParser.Parse(formData.Query), cancellationToken);
    }

    private class FormData
    {
        public FormData(string knowledgeBaseDescription, string knowledge, string query)
        {
            this.KnowledgeBaseDescription = knowledgeBaseDescription;
            this.Knowledge = knowledge;
            this.Query = query;
        }

        public string KnowledgeBaseDescription { get; set; }

        public string Knowledge { get; set; }

        public string Query { get; set; }
    }
}