@page "/docs/language-integration"

<PageTitle>Language Integration</PageTitle>

<h1>Language Integration</h1>

<p>This document details the language integration features of SCFirstOrderLogic.
These features reside in the SCFirstOrderLogic.LanguageIntegration namespace.</p>

<p>No doubt there are countless first-order logic libraries out there for .NET (edit: actually, no, it turns out that there aren't).
The only perhaps non-obvious part of this one is the classes in the LanguageIntegration namespace, which allow for specifying FoL sentences as LINQ expressions.
That is, rather than directly giving the knowledge base sentences of first order logic as instances of the Sentence class, we (represent domains as IEnumerable&lt;TElement&gt; and) `Tell` an `IKnowledgeBase` bool-valued expressions that are guaranteed to be true for all models that it will be `Ask`ed about - which the knowledge base then converts into the entailed sentences of first order logic.</p>

<p>Benefits of using LINQ expressions:</p>

<ul>
    <li>Your sentences of propositional logic can be expressed in the familiar, plain-old C#, with the operators you would expect (e.g. `&&`, `||` and `!`).</li>
    <li>Further, your rules are expressed in code that is directly integrable with domain implementations, should they exist. This (may turn out to be useless, but) may:
        <ul>
            <li>Provide a way of integrating the rest of your business logic (in particular, known constants) with the knowledge base.
For example, a knowledge base could derive known constants and their functions/predicates by enumerating an actual implementation of IEnumerable&lt;TElement&gt;.
Of course, the fact that we often only know particular things about constants doesn't mesh particularly well with having a real object graph.
However, given that any implementation is likely to be an adapter anyway (as, for example, SCFirstOrderLogic doesn't engage with the .NET type system - more on this below),
there could be a convention based thing where exceptions thrown by the implementation are classed as unknowns by the knowledge base.
This may (probably will..) turn out to be more complex than is useful, but you never know (and the real goal here is teaching myself FoL anyway, so I'm not too fussed if it doesn't pan out).</li>
            <li>Provide a way of validating a domain implementation with the knowledge base.</li>
        </ul>
    </li>
    <li>LINQ already includes much of the plumbing to make this happen - expression trees, visitor classes etc - making the conversion from one to the other fairly straightforward.</li>
</ul>

<p>Drawbacks of using LINQ expressions:</p>

<ul>
    <li>Obviously (as alluded to above, and also mentioned below), allowing for constants declared at runtime raises some (surmountable) challenges.</li>
    <li>By using C#, there is a danger in confusing C# operators with the elements of first order logic that they are mapped to - creating a risk to learning outcomes.
That is, while it may be intuitive to map the C# `||` operator to a disjunction in FoL, they do of course represent very different things.
Compared to uses of LINQ such as LINQ to SQL (where the system being mapped to is very obviously distinct), it is perhaps less obvious that there IS still a different system (first order logic) being mapped to here. This is important to bear in mind while working with this the types in this namespace.</li>
    <li>Simple FoL sentences are nice and simple to represent in C#, but more complex ones get a little gnarly. An example from the source text book, `∀x [∀y Animal(y) ⇒ Loves(x, y)] ⇒ [∃y Loves(y, x)]` ("everyone who loves all animals is loved by something"), is the following in C#: `d => d.All(x => If(d.All(y => If(y.IsAnimal, x.Loves(y))), d.Any(y => y.Loves(x))))`.</li>
</ul>

<p>Before we dive into the details, a few things to note about this:</p>

<ul>
    <li>As mentioned above, the general approach is to have domain types (can be - in fact is recommended to be - just an interface) that implement IEnumerable&lt;TElement&gt;, where TElement is a type for **all** (more on this in the third bullet) elements of the domain. This approach provides a few useful qualities:
        <ul>
            <li>Using IEnumerable&lt;T&gt; gives us an obvious choice for representing quantifiers - the `All` extension method for universal quantification, and `Any` for existential quantification.</li>
            <li>Allowing the domain to be some type that implements this interface - as opposed to assuming that a domain is IEnumerable&lt;TElement&gt; itself - is useful because it allows constants and ground predicates to be defined on the domain type.</li>
        </ul>
    </li>
    <li>Also as mentioned above, when `Tell`ing facts to knowledge base instances, the fundamental rule is that FoL sentences are entailed by the assertion that the provided C# expression is guaranteed to evaluate to "true" for all models that the knowledge base will be `Ask`ed about.</li>
    <li>You will note that it doesn't really engage with the .NET type system beyond establishing type-safety based on the terminology used in the domain.
That is, there's nothing in here about being able to use the fact that a domain element (as an object in .NET) is of a particular type or not.
Instead, predicates must be defined as properties or methods on a singular TElement type. On the upside, this keeps things simple. On the downside, this means you can't be quite as expressive as you might be hoping.
And as mitigations to the downside:
        <ol>
            <li>if you actually need to map to a real instantiated domain (for e.g. validation purposes), writing an adapter that implements predicates based on runtime type should be relatively straightforward. If that doesn't quite make sense, I'm hoping it will once you look at the examples..</li>
            <li>if this works, I may revisit this to see what extensions can be made in this area.</li>
        </ol>
    </li>
</ul>

<p>The mapping between bool-valued C# expressions (that act on the TDomain) and FoL sentences can be found in the table below:</p>

<table class="table">
    <thead>
        <tr>
            <th scope="col">FoL</th>
            <th scope="col">FoL Syntax</th>
            <th scope="col">C# Expression</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Conjunction</td>
            <td><code>{sentence} ∧ {sentence}</code></td>
            <td><code>{expression} {&& or &} {expression}</code></td>
        </tr>
        <tr>
            <td>Disjunction</td>
            <td><code>{sentence} ∨ {sentence}</code></td>
            <td><code>{expression} {|| or |} {expression}</code></td>
        </tr>
        <tr>
            <td>Material equivalence</td>
            <td><code>{sentence} ⇔ {sentence}</code></td>
            <td><code>Operators.Iff({expression}, {expression})</code> *</td>
        </tr>
        <tr>
            <td>Material implication</td>
            <td><code>{sentence} ⇒ {sentence}</code></td>
            <td><code>Operators.If({expression}, {expression})</code> *</td>
        </tr>
        <tr>
            <td>Negation</td>
            <td><code>¬{sentence}</code></td>
            <td><code>!{expression}</code></td>
        </tr>
        <tr>
            <td>Existential quantification</td>
            <td><code>∃ {variable}, {sentence}</code></td>
            <td><code>{domain}.Any({variable} => {expression})</code> †</td>
        </tr>
        <tr>
            <td>Universal quantification</td>
            <td><code>∀ {variable}, {sentence}</code></td>
            <td><code>{domain}.All({variable} => {expression})</code> †</td>
        </tr>
        <tr>
            <td>Equality</td>
            <td><code>{term} = {term}</code></td>
            <td><code>{expression} == {expression}</code></td>
        </tr>
        <tr>
            <td>Predicate</td>
            <td><code>{predicate symbol}({term}, ..)</code></td>
            <td>A boolean-valued property or method call on a TElement, or a boolean-valued property or method call on TDomain (for ground predicates).</td>
        </tr>
        <tr>
            <td>Constant</td>
            <td><code>{constant symbol}</code></td>
            <td>Access of a TElement-valued property or parameterless method on TDomain ‡</td>
        </tr>
        <tr>
            <td>Function</td>
            <td><code>{function symbol}({term}, ...)</code></td>
            <td>Invocation of a TElement-valued method on TElement that accepts only TElement-valued paramaters, or access of a TElement-valued property of TElement</td>
        </tr>
        <tr>
            <td>Variable</td>
            <td><code>{variable symbol}</code></td>
            <td>A variable from the lambda passed to All or Any</td>
        </tr>
    </tbody>
</table>

<p>* C# lacks a single operator appropriate for material equivalence and implication, so we offer some shorthand methods in the `Operators` static class.
Library consumers are encouraged use `using static SCFirstOrderLogic.LanguageIntegration.Operators;` where appropriate</p>

<p>† We also define some more overloads of `All` and `Any` that accept multiple parameters - which can help with keeping expressions simple when there are multiple variables involved</p>

<p>‡ How to deal effectively with constants is an open question.
At present, they can be declared as TElement-valued props on the domain, but this doesn't facilitate scenarios where being able to define constants at run-time is a requirement.
A couple of notes:</p>

<ul>
    <li>Of course, existential quantification can be used in many cases `d => d.Any(x => x.Predicate1 && ..)`. We only need a constant when we need to refer to the same entity across different sentences.</li>
    <li>Aside from the domain implementation thing mentioned above, keyed collections of constants are another (simpler) approach, but exactly how is the question.
        Convention-based (e.g. any TElement-valued indexer..), something stronger (e.g. domains can or must implement IRuntimeConstantContainer&lt;TElement&gt; which defines an object-keyed, TElement-valued indexer?), or something else?</li>
</ul>


