// Copyright (c) 2021-2023 Simon Condon.
// You may use this file in accordance with the terms of the MIT license.
using Antlr4.Runtime;
using Antlr4.Runtime.Misc;
using SCFirstOrderLogic.SentenceCreation.Antlr;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace SCFirstOrderLogic.SentenceCreation
{
    /// <summary>
    /// Parser for first-order logic sentences.
    /// </summary>
    // TODO-FEATURE: All identifiers are just strings (i.e. the token text) for the mo.
    // Might be useful to allow for callbacks (Func<string, object> getPredicateIdentifier etc) in case the caller needs richer identifiers.
    public static class SentenceParser
    {
        /// <summary>
        /// Parses a string containing first-order logic syntax into a <see cref="Sentence"/> object.
        /// </summary>
        /// <param name="sentence">The string to parse.</param>
        /// <returns>The parsed <see cref="Sentence"/>.</returns>
        public static Sentence Parse(string sentence)
        {
            return new SentenceTransformation().Visit(MakeParser(sentence).singleSentence().sentence());
        }

        /// <summary>
        /// Parses a string containing zero or more sentences into a <see cref="Sentence"/> array.
        /// Sentences can be separated by a semi-colon and/or whitespace, but it is not required.
        /// </summary>
        /// <param name="sentences">The string to parse.</param>
        /// <returns>A new array of sentences.</returns>
        public static Sentence[] ParseList(string sentences)
        {
            return MakeParser(sentences).sentenceList()._sentences
                .Select(s => new SentenceTransformation(Enumerable.Empty<VariableDeclaration>()).Visit(s))
                .ToArray();
        }

        private static FirstOrderLogicParser MakeParser(string input)
        {
            AntlrInputStream inputStream = new(input);

            // NB: ANTLR apparently adds a listener by default that writes to the console.
            // Which is crazy default behaviour if you ask me, but never mind.
            // We remove it so that consumers of this lib don't get random messages turning up on their console.
            FirstOrderLogicLexer lexer = new(inputStream);
            lexer.RemoveErrorListeners();
            CommonTokenStream tokens = new(lexer);

            // NB: In the parser, we add our own error listener that throws an exception.
            // Otherwise errors would just be ignored and the method would just return null, which is obviously bad behaviour.
            FirstOrderLogicParser parser = new(tokens);
            parser.RemoveErrorListeners();
            parser.AddErrorListener(ThrowingErrorListener.Instance);

            return parser;
        }

        private class ThrowingErrorListener : BaseErrorListener
        {
            public static ThrowingErrorListener Instance = new ThrowingErrorListener();

            public override void SyntaxError(TextWriter output, IRecognizer recognizer, IToken offendingSymbol, int line, int charPositionInLine, string msg, RecognitionException e)
            {
                throw new ArgumentException("line " + line + ":" + charPositionInLine + " " + msg, "sentence");
            }
        }

        // Visitor that transforms from a syntax tree generated by ANTLR to a Sentence instance
        private class SentenceTransformation : FirstOrderLogicBaseVisitor<Sentence>
        {
            private readonly IEnumerable<VariableDeclaration> variablesInScope;
            private readonly TermTransformation termTransformation;

            public SentenceTransformation()
                : this(Enumerable.Empty<VariableDeclaration>())
            {
            }

            public SentenceTransformation(IEnumerable<VariableDeclaration> variablesInScope)
            {
                this.variablesInScope = variablesInScope;
                termTransformation = new TermTransformation(variablesInScope);
            }

            public override Sentence VisitPredicate([NotNull] FirstOrderLogicParser.PredicateContext context)
            {
                return new Predicate(
                    context.ID().Symbol.Text,
                    context.argumentList()._elements.Select(e => termTransformation.Visit(e)));
            }

            public override Sentence VisitNegation([NotNull] FirstOrderLogicParser.NegationContext context)
            {
                return new Negation(Visit(context.sentence()));
            }

            public override Sentence VisitEquivalence([NotNull] FirstOrderLogicParser.EquivalenceContext context)
            {
                var subSentences = context.sentence();
                return new Equivalence(Visit(subSentences[0]), Visit(subSentences[1]));
            }

            public override Sentence VisitConjunction([NotNull] FirstOrderLogicParser.ConjunctionContext context)
            {
                var subSentences = context.sentence();
                return new Conjunction(Visit(subSentences[0]), Visit(subSentences[1]));
            }

            public override Sentence VisitExistentialQuantification([NotNull] FirstOrderLogicParser.ExistentialQuantificationContext context)
            {
                var newVariables = context.declarationList()._elements.Select(e => new VariableDeclaration(e.Text));

                Sentence MakeSentence(IEnumerable<VariableDeclaration> remainingVariables)
                {
                    if (!remainingVariables.Any())
                    {
                        return new SentenceTransformation(variablesInScope.Concat(newVariables)).Visit(context.sentence());
                    }
                    else
                    {
                        return new ExistentialQuantification(remainingVariables.First(), MakeSentence(remainingVariables.Skip(1)));
                    }
                }

                return MakeSentence(newVariables);
            }

            public override Sentence VisitDisjunction([NotNull] FirstOrderLogicParser.DisjunctionContext context)
            {
                var subSentences = context.sentence();
                return new Disjunction(Visit(subSentences[0]), Visit(subSentences[1]));
            }

            public override Sentence VisitImplication([NotNull] FirstOrderLogicParser.ImplicationContext context)
            {
                var subSentences = context.sentence();
                return new Implication(Visit(subSentences[0]), Visit(subSentences[1]));
            }

            public override Sentence VisitBracketedSentence([NotNull] FirstOrderLogicParser.BracketedSentenceContext context)
            {
                return Visit(context.sentence());
            }

            public override Sentence VisitPredicateEquality([NotNull] FirstOrderLogicParser.PredicateEqualityContext context)
            {
                var arguments = context.term();
                return new Predicate(
                    EqualityIdentifier.Instance,
                    new[] { termTransformation.Visit(arguments[0]), termTransformation.Visit(arguments[1]) });
            }

            public override Sentence VisitUniversalQuantification([NotNull] FirstOrderLogicParser.UniversalQuantificationContext context)
            {
                var newVariables = context.declarationList()._elements.Select(e => new VariableDeclaration(e.Text));

                Sentence MakeSentence(IEnumerable<VariableDeclaration> remainingVariables)
                {
                    if (!remainingVariables.Any())
                    {
                        return new SentenceTransformation(variablesInScope.Concat(newVariables)).Visit(context.sentence());
                    }
                    else
                    {
                        return new UniversalQuantification(remainingVariables.First(), MakeSentence(remainingVariables.Skip(1)));
                    }
                }

                return MakeSentence(newVariables);
            }
        }

        // Visitor that transforms from a syntax tree generated by ANTLR to a Term instance
        private class TermTransformation : FirstOrderLogicBaseVisitor<Term>
        {
            private readonly IEnumerable<VariableDeclaration> variablesInScope;

            public TermTransformation(IEnumerable<VariableDeclaration> variablesInScope)
            {
                this.variablesInScope = variablesInScope;
            }

            public override Term VisitVariableOrConstant([NotNull] FirstOrderLogicParser.VariableOrConstantContext context)
            {
                var symbolText = context.ID().Symbol.Text;
                var matchingVariableDeclaration = variablesInScope.SingleOrDefault(v => v.Identifier.Equals(symbolText));
                if (matchingVariableDeclaration != null)
                {
                    // symbol text matches a variable that's in scope - interpret as a reference to it
                    return new VariableReference(matchingVariableDeclaration);
                }
                else
                {
                    // symbol text doesn't match any variable in scope - interpret as a constant
                    return new Constant(symbolText);
                }
            }

            public override Term VisitFunction([NotNull] FirstOrderLogicParser.FunctionContext context)
            {
                return new Function(
                    context.ID().Symbol.Text,
                    context.argumentList()._elements.Select(e => Visit(e)));
            }
        }
    }
}