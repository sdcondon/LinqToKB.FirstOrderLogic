using SCFirstOrderLogic.Inference.Unification;
using SCFirstOrderLogic.SentenceManipulation;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace SCFirstOrderLogic.Inference.Chaining
{
    /// <summary>
    /// Query implementation used by <see cref="SimpleBackwardChainingKnowledgeBase"/>.
    /// </summary>
    public class SimpleBackwardChainingQuery : IQuery
    {
        private readonly Predicate query;
        private readonly IReadOnlyDictionary<object, List<CNFDefiniteClause>> clausesByConsequentSymbol;

        private IEnumerable<VariableSubstitution>? substitutions;

        internal SimpleBackwardChainingQuery(Predicate query, IReadOnlyDictionary<object, List<CNFDefiniteClause>> clausesByConsequentSymbol)
        {
            this.query = query;
            this.clausesByConsequentSymbol = clausesByConsequentSymbol;
        }

        /// <inheritdoc />
        public bool IsComplete => substitutions != null;

        /// <inheritdoc />
        public bool Result => substitutions?.Any() ?? throw new InvalidOperationException("Query is not yet complete");

        /// <summary>
        /// Gets the proof tree generated by the query.
        /// </summary>
        ////public ProofTree Proof { get; }

        /// <summary>
        /// Gets the set of variable substitutions that can be made to satisfy the query.
        /// Result will be empty if and only if the query returned a negative result.
        /// </summary>
        public IEnumerable<VariableSubstitution> Substitutions => substitutions ?? throw new InvalidOperationException("Query is not yet complete");

        /// <inheritdoc />
        public void Dispose()
        {
        }

        /// <inheritdoc />
        public Task<bool> ExecuteAsync(CancellationToken cancellationToken = default)
        {
            substitutions = VisitPredicate(query, new VariableSubstitution());
            return Task.Run(() => Result, cancellationToken);
        }

        /// <summary>
        /// Attempt to verify the truth of a predicate by (recursively) attempting to verify the truth of at least one of the clauses for which it is a consequent -
        /// making only variable substitutions that do not conflict with substitutions already made.
        /// </summary>
        /// <param name="goal">The predicate in question.</param>
        /// <param name="unifier">The current unifier.</param>
        /// <returns></returns>
        private IEnumerable<VariableSubstitution> VisitPredicate(Predicate goal, VariableSubstitution unifier)
        {
            if (clausesByConsequentSymbol.TryGetValue(goal.Symbol, out var clausesWithThisGoal))
            {
                foreach (var clause in clausesWithThisGoal)
                {
                    var updatedUnifier = new VariableSubstitution(unifier);

                    if (LiteralUnifier.TryUpdate(clause.Consequent, goal, updatedUnifier))
                    {
                        foreach (var result in VisitConjuncts(clause.Conjuncts, updatedUnifier))
                        {
                            yield return result;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Attempt to verify the truth of all a set of conjoined predicates in a particular clause by (recursively) attempting to verify each conjunct -
        /// making only variable substitutions that do not conflict with substitutions already made.
        /// </summary>
        /// <param name="conjuncts">The conjuncts in question.</param>
        /// <param name="unifier">The current unifier.</param>
        /// <returns></returns>
        private IEnumerable<VariableSubstitution> VisitConjuncts(IEnumerable<Predicate> conjuncts, VariableSubstitution unifier)
        {
            // TODO: WRONG! wont fail if a conjunct fails. Tests first, then change.

            if (!conjuncts.Any())
            {
                yield return unifier;
            }
            else
            {
                foreach (var firstPredicateResult in VisitPredicate(unifier.ApplyTo(conjuncts.First()).Predicate, unifier))
                {
                    foreach (var result in VisitConjuncts(conjuncts.Skip(1), firstPredicateResult))
                    {
                        yield return result;
                    }
                }
            }
        }

        /// <summary>
        /// Container for a proof tree (or sub-tree) created by a <see cref="SimpleBackwardChainingQuery"/>.
        /// </summary>
        ////public class ProofTree
        ////{
        ////    /// <summary>
        ////    /// Initializes a new instance of the <see cref="ProofTree"/> class.
        ////    /// </summary>
        ////    /// <param name="root">The root clause of the tree.</param>
        ////    /// <param name="subTreesByRootNode">The sub-trees that follow the root clause, keyed by the predicate that they prove.</param>
        ////    internal ProofTree(CNFDefiniteClause root, IReadOnlyDictionary<Predicate, ProofTree> subTreesByRootNode)
        ////    {
        ////        Root = root ?? throw new ArgumentNullException(nameof(root));
        ////        SubTrees = subTreesByRootNode ?? throw new ArgumentNullException(nameof(subTreesByRootNode));
        ////    }

        ////    // Private because this is only allowed for the empty tree.
        ////    private ProofTree() => (Root, SubTrees) = (default, null);

        ////    /// <summary>
        ////    /// Gets an empty tree - that indicates that a known predicate (i.e. unit clause) has been reached.
        ////    /// </summary>
        ////    public static ProofTree Empty { get; } = new ProofTree();

        ////    /// <summary>
        ////    /// Gets the root clause of the tree.
        ////    /// </summary>
        ////    public CNFDefiniteClause Root { get; }

        ////    /// <summary>
        ////    /// Gets the sub-trees that follow the root clause, keyed by the predicate that they prove.
        ////    /// </summary>
        ////    public IReadOnlyDictionary<Predicate, ProofTree> SubTrees { get; }

        ////    /// <summary>
        ////    /// Flattens the tree out into a single mapping from the predicate to the clause used to prove it.
        ////    /// Intended to make trees easier to work with in certain situations (e.g. assertions in tests).
        ////    /// <para/>
        ////    /// Each predicate will occur at most once in the entire tree, so we can always safely do this.
        ////    /// </summary>
        ////    /// <returns>A mapping from the current node to the edge that should be followed to ultimately reach only target nodes.</returns>
        ////    public IReadOnlyDictionary<Predicate, CNFDefiniteClause> Flatten()
        ////    {
        ////        var flattened = new Dictionary<Predicate, CNFDefiniteClause>();

        ////        void Visit(ProofTree tree)
        ////        {
        ////            if (!tree.Equals(ProofTree.Empty))
        ////            {
        ////                flattened[tree.Root.Consequent] = tree.Root;
        ////                foreach (var subPlan in tree.SubTrees.Values)
        ////                {
        ////                    Visit(subPlan);
        ////                }
        ////            }
        ////        }

        ////        Visit(this);

        ////        return flattened;
        ////    }
        ////}
    }
}
